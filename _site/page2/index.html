<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>分享创造价值, 转播知识精华 &#8211; 云知道</title>
<meta name="description" content="分享创造价值, 转播知识精华">
<meta name="keywords" content="Docker, linux, cloud, paas, iaas, puppet">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yzd.io/images/header2.jpg">

<meta name="twitter:title" content="分享创造价值, 转播知识精华">
<meta name="twitter:description" content="分享创造价值, 转播知识精华">
<meta name="twitter:creator" content="@zliu">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="分享创造价值, 转播知识精华">
<meta property="og:description" content="分享创造价值, 转播知识精华">
<meta property="og:url" content="http://yzd.io/page2/">
<meta property="og:site_name" content="云知道">

<meta name="google-site-verification" content="DxU8FigBXmBKSOyiIr11sF7OqgJAR0FbAxEtV3bMnks">
<meta name="msvalidate.01" content="12F570013342D1F8B60A455D09221C1D">


<link rel="canonical" href="http://yzd.io/page2/">
<link href="http://yzd.io/feed.xml" type="application/atom+xml" rel="alternate" title="云知道 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://yzd.io/assets/css/main.css">
<!-- Webfonts -->
<link href="http://fonts.useso.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://yzd.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://yzd.io/">首页</a></li>
		<li><a href="http://yzd.io/posts/">归档</a></li>
		<li><a href="http://yzd.io/tags/">标签</a></li>
		<li>
			<a href="#">关于</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://yzd.io/images/head-200-200.jpg" alt="Martin Liu photo" class="author-photo">
					<h4>Martin Liu</h4>
					<p>Blogger, runner, opensource fans</p>
				</li>
				<li><a href="http://yzd.io/about/"><span class="btn btn-inverse">了解本站</span></a></li>
				<li>
					<a href="mailto:67120666@qq.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/zliu"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				
				
				
				<li>
					<a href="https://github.com/martinliu"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://yzd.io/images/header2.jpg" alt="分享创造价值, 转播知识精华">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>云知道</h1>
      <h2>分享创造价值, 转播知识精华</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-10-04T16:00:00+00:00"><a href="http://yzd.io/cluster-management/why-microsoft-want-to-buy-mesophere/">October 04, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://yzd.io/about/" title="About Martin Liu">Martin Liu</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
预计阅读时间 ~1 分钟

      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://yzd.io/cluster-management/why-microsoft-want-to-buy-mesophere/" rel="bookmark" title="为什么微软欲10亿收购Mesosphere" itemprop="url">为什么微软欲10亿收购Mesosphere</a></h1>
    
  </header>
  <div class="entry-content">
    <p>具报道微软正在和一家快速增长的云计算创业公司 <a href="https://mesosphere.com/">Mesosphere</a> 商讨并购事宜。根据湾区行业媒体 “The Information” 记者 Amir Efrati 的报道，这家创业公司目前估值接近10亿美元。</p>

<p>交易的细节目前还不清楚 —— 记者没有说明交易进行到哪个阶段，也没有说明微软内部对于这个估值的态度。 Mesosphere 和微软都对这个消息表示无可奉告。</p>

<p>让微软开出如此天价的除了 Mesosphere 的技术，最近硅谷对于软件定义的数据中心的热情肯定也是个因素。数十亿美元的热钱涌入这个领域，创业公司门前排满了传统 IT 巨头，谁也不想在制定行业标准和抢占行业制高点方面丢了先机。到底 Mesosphere 到底是何方神圣，为何能十亿级别估值？</p>

<h2 id="mesosphere-">Mesosphere 这个公司是干啥的？</h2>

<p>作为一家飞速增长的创业公司，自 2013 年来 Mesosphere 专注于围绕开源软件 Apache Mesos 开发产品和服务。Twitter 这样的巨头为了应对集群的飞速膨胀，借助 Mesos 将数以千计的服务器整合地像使用一台电脑，同时还管理运行这台“电脑”中成千上万的任务。 另外一家独角兽公司 Docker，则支持将他们火爆的容器产品部署到 Mesos 集群中。Docker 依靠其简单灵活的容器产品一夜成名，开发者终于能够在统一的环境中开发、测试和发布应用，将过去数周的工作缩减到几个小时。Yelp 这样的巨头就将 Mesos 和 Docker 组合起来，使用 Mesos 将整个数据中心变成一个资源池，然后通过 Docker 将应用部署到整个集群。</p>

<p>类似其他提供基础设施和数据的管理软件的创业公司，Mesosphere 也来自真正拥有“大数据”的门派。CEO Florian Leibert 在独立创业之前，曾经是 Airbnb 和 Twitter 的技术负责人（就连巨头 Google 内部也有一个功能类似 Mesos 的管理平台 Borg）。Leibert 将 Mesos 引入了 Airbnb，这样技术团队可以轻松地在其上搭建 Spark 大数据运算系统。</p>

<p>今年春天在一次福布斯杂志采访中，Leibert 告诉记者他们的产品能让数据中心非常容易管理，不论里面有五台还是五千台机器。一个佐证是掌管着 Twitter 数千台服务器仅仅是屈指可数的几位运维工程师。</p>

<p>说起他们创业最苦逼的事情，Leibert 苦笑道 “怎么和大家说明白我们是干啥的”。最后总结成一句话，让你们服务器的利用率提高两三倍。</p>

<h2 id="section">微软 看上她哪点了？</h2>

<p>从微软的角度来说，通过并购获得 Mesos 技术，就能够迅速在这一波软件定义的基础设施大潮中站稳脚跟。之前 LinkedIn 已经天使投资了另外一家相同领域的创业公司 Confluent，Google 和 IBM 则联合 Docker、Mesosphere 一起来制定新的容器标准（Open Container Project），微软至今毫无建树。正如 Efrati 在他的访谈中提到，虽然微软已经参与了 Docker 项目，但在上述大领域中还没有能占一席之地的项目。</p>

<p>大家不要忘记，六月份的时候坊间曾经流传微软要并购 Docker。根据微软的风格，在做出并购决定之前，还会仔细评估这些创业公司一阵。</p>

<p>2014年底，Mesosphere 得到了 Khosla Venture 的3600万美元B轮融资，之前A轮则是由 Andreessen Horowitz 领投。根据 Pitchbook 的数据，Mesosphere 的 A 轮估值约为 4500 万美元，B 轮之后增加到数亿美元。同期 Docker 公司经过 C 轮融资估值达到 4 亿美元，随后四月份更是加入了独角兽俱乐部（十亿美元）。</p>

<p>虽然我们现在还不确定未来 Docker 被巨头并购时的估值，但是 Mesospher 如果能够比 Docker 成长地更快，那么虽然盈利不大，但足以让它的估值从一亿美元猛增到十亿美元（在新兴产业领域，人们对增长速度的关注远远高于现实盈利）。如果最终证实了 The Information 报道的估值，也算是个合情合理的价格。</p>

<p>大家都拭目以待的是微软是否真的下定决心在这个新兴领域放手一搏，就算竞争对手已经找好了同盟军。当然大家也关心 Mesosphere 是否现在就想卖，即使这个估值听起来已经不太小。</p>

<p>来自：2015-08-19 福布斯记者 Alex Konrad
http://www.forbes.com/sites/alexkonrad/2015/08/18/why-microsoft-could-reportedly-want-to-buy-cloud-startup-mesosphere-even-at-1-billion/#rd</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-10-03T16:00:00+00:00"><a href="http://yzd.io/container/china-docker-service-product-overview/">October 03, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://yzd.io/about/" title="About Martin Liu">Martin Liu</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
预计阅读时间 ~1 分钟

      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://yzd.io/container/china-docker-service-product-overview/" rel="bookmark" title="国内Docker服务和产品初探" itemprop="url">国内Docker服务和产品初探</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="section">各家产品感受</h2>

<p>我知道的Docker创业团队一共五个：DaoCloud、cSphere、Alauda、TenxCloud、DataMan，除了最后一个数人重点在Mesos+Docker，没找到在线试用的门路，其它几个都初步试了一下，下面分别说明。</p>

<p>说明：Docker相关产品变化很快，我只能说自己试用时的情况，在文章发出后读者看到的功能可能会有所不同</p>

<h2 id="daocloud">DaoCloud</h2>

<p>似乎不能直接用 hub.docker.com 上的镜像制作服务集成只能依赖源码中或者线上编写的 docker-compose.yml ，对线上操作有些不便有些时候访问比较慢在有限的几次操作中，发现构建速度比 alauda 快一开始没找到提 bug/issue 的地方，后来找到后觉得界面融合的很好只能部署在自己注册的宿主机上，好处是可以保持控制力，缺点是缺省没有跨主机的部署方案集成测试仅仅是一个容器内玩点脚本，如果想要做微服务的集成似乎不可行。</p>

<h2 id="csphere">cSphere</h2>

<p>系列培训做的很不错，但是每一次时间有些长，对学习者的要求比较高，建议切割成几部分提供了一个完整的产品可以用于自己搭建，用户容易有掌控感安装很简单，交付的产品上手很容易（同类产品没有找到安装私有云环境的方法）不知道如何进行跨单机的容器协作有些小问题需要处理（比如 web 界面上 hostname 同名时的选择问题），但没有源码无法提 patch 以机器/容器视角进行管控，显得抽象不足，期望是结合 compose 以镜像/服务视角进行管理。</p>

<h2 id="alauda">Alauda</h2>

<p>不知道LB用的是什么方案？是否能跨机操作构建时选择国内和国际两种情况比较赞，有些镜像是在国内构建比较快提供存储卷服务，便于应用服务编排，但是不知道如何跨机构建服务，设定环境变量值的时候需要设置一个较长的字符串（secret seed），结果显示不太好看缺省的服务数量有上限，最多 4 个服务，2 个 cpu工单系统看上去有点low，如果不能做漂亮，不如学csphere直接搭一个开源论坛进行互动。</p>

<h2 id="tenxcloud">TenxCloud</h2>

<p>字体比灵雀云好看些，比较舒心与 DaoCloud 类似，也不能直接用 hub.docker.com 上的镜像制作服务获取github上的项目列表时有数量限制，已经修复不能获取源码仓库的分支内容，已经修复构建系统支持国际/国内节点的区分构建系统可以选择程序类型，感觉这个功能会成为鸡肋对 IAAS 厂商仅支持AWS，期待支持 qingcloud、ucloud、aliyun 服务编排的 UI 界面看似很好，但其实用处不大</p>

<h2 id="docker">对Docker服务的整体探讨</h2>

<p>从知道Docker这个产品开始，我就一直期望Docker能够为软件/互联网企业带来一些有价值的东西。现有的场景下，Docker既是一个软件，又是一个技术生态，围绕这一技术，各家公司都在努力解决Docker集群的管理问题，希望为软件和互联网企业带来价值，而具体做法各有异同。</p>

<p>下面进行一些综合性质的讨论，为了方便，我们把基于docker技术来管理镜像、构建过程和各种服务编排的平台称为Docker云平台。</p>

<h3 id="section-1">产品形态</h3>

<p>目前主要有两种产品交付方式——</p>

<ol>
  <li>开发 Docker 云平台，以 image 交付产品，支持用户自建 Docker 管理集群，公司提供培训和软件咨询服务</li>
  <li>在线提供 Docker 云平台，以 SaaS 形式交付服务，底层可以使用 IaaS 服务，通过用户账号接入其它 IaaS 平台</li>
</ol>

<p>前一种可以给予用户更多的掌控，但从长远考虑，如果由客户自己运维Docker云平台，势必需要一个专业的运维团队，这会给企业带来很大的运作成本，所以前一种方式仅仅有利于客户培养，未来应该以后一种方式为主。</p>

<p>后一种方式的主要代价是企业不好控制自己的数据安全，后来了解到的一种办法是使用所谓的 hosted private cloud ，这样企业仍然需要做一些基础运维工作，但是主要局限于软件环境，可以看做是安全和成本的一种平衡。</p>

<h3 id="section-2">网络解决方案</h3>

<p>Docker 由于其轻量级的特点，很容易就可以在一个宿主机上运行多个容器，这使得我们可以用低廉的成本在单机上进行分布式集成测试，但这是研发和测试的需求，线上的着眼点必然要支持跨宿主机，以支持包括弹性扩容之类的运维能力。</p>

<p>目前已知的网络方案尚无公认的最佳实践，我看到的方式大都还是以 bridge+NAT 为主，这块期待突破，也希望了解各家 Docker 团队对 Swarm 的支持。</p>

<h3 id="section-3">服务编排</h3>

<p>服务编排是 Docker 类应用从玩具到真正系统的一个分水岭，但是各家支持不尽相同。</p>

<ul>
  <li><strong>不支持</strong> 仅支持Docker的单个容器视角，这样会让用户把Docker当做简化的虚拟机来使用，特别是功能菜单也类似IaaS系统的信息结构时。</li>
  <li><strong>简单支持</strong> 借助 Docker Compose ，在同一个宿主机上使用 docker-compose.yml 文件做服务编排，未来也可以借助 swarm + compose 组合跨越宿主机。</li>
  <li><strong>较高级功能支持</strong> 将 compose 中的各种要素进行拆解，用户使用web表单提交需要的编排方式，这个做法简化了用户编写 yaml 文件的工作，但是需要对 compose 的信息结构进行消化，使之适应 web 表单的展现方式。</li>
</ul>

<p>服务编排的结构对线上和开发测试可能有所差异，所以有一种做法是对不同的环境编写不同的 yaml 文件，但我对这个做法持保留态度，因为这会让各种环境的一致性受到破坏。</p>

<p>目前比较好的做法可能是分析 yaml 文件中的服务依赖，然后利用 external_links 建立对外部资源的依赖，而在不同的环境下，自然有不同的外部资源来提供。</p>

<h3 id="section-4">存储解决方案</h3>

<p>docker 本身应该是无状态服务，所以状态的管理非常重要，通常做法是在宿主机上提供挂载卷，由 docker 云平台提供存储迁移和备份服务，这应该是 docker 云平台的一个重要功能。</p>

<h3 id="section-5">跨越地理节点</h3>

<p>这里指的是跨机房协作，通常仅与线上运维相关，而与开发和测试关系不大。</p>

<p>这块工作对 Docker 云平台有所要求，若要协作不同机房的 docker 容器，势必需要一个建立在公共域的管控中心，那么安全策略和模型、网络管理方式都会与同网段宿主机群的时候大为不同。</p>

<p>同网段宿主机群是可以互相网络可达的，所以一般是这样：</p>

<p>Host A &lt;–(控制)— Controller Node
Host B &lt;–(控制)—
Host C &lt;–(控制)—</p>

<p>跨机房的时候，控制中心通常不能直连宿主机群，所以需要变通：</p>

<p>Host A —(agent上报，查询并执行命令) –&gt; Controller Node
Host B —(agent上报，查询并执行命令) –&gt;
Host C —(agent上报，查询并执行命令) –&gt;</p>

<p>当然，如果对自己的控制链路有信心，我其实更倾向于免agent的方案，即将sshd看做缺省就有的agent，只是在每个机房留一个broker即可，好处是减少对宿主机的干预和维护成本。</p>

<p>Host A &lt;–(管控)– Broker –(查询并执行命令) –&gt; Controller Node
Host B &lt;–(管控)—
Host C &lt;–(管控)—</p>

<p>实践中的这块情况了解有限，目前仅知道 Mesos 是模式一，因此不能跨机房，而k8s是模式二，可以很容易的跨越机房和IaaS服务商。</p>

<p>文章来源：<a href="http://dockone.io/article/707">http://dockone.io/article/707</a></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-10-01T16:00:00+00:00"><a href="http://yzd.io/container/uninofs-storage-volume-faq/">October 01, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://yzd.io/about/" title="About Martin Liu">Martin Liu</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
预计阅读时间 ~4 分钟

      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://yzd.io/container/uninofs-storage-volume-faq/" rel="bookmark" title="FAQ： 关于 Union Filesystems, Storage 和 Volumes" itemprop="url">FAQ： 关于 Union Filesystems, Storage 和 Volumes</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="docker-image-">Docker image 是分层的意味着什么?</h2>

<p>It literally means that a docker images is built on layers. Each layer represents a portion of the images file system that either adds to or replaces the layer below it. For instance you might start with a Debian image, and then add Emacs, and the Apache. Finally, when you instantiate a container a final read-write layer to capture any changes that are made to the container.</p>

<h2 id="union-file-system-">Union file system 是什么?</h2>

<p>A union file system is a file system that amalgamates a collection of different file systems and directories (called branches) into a single logical file system.</p>

<h2 id="unionfs-">UnionFS 是分布式文件系统么？</h2>

<p>No, it is not.</p>

<h2 id="docker-storage-drivers--volumes-">Docker Storage Drivers 和 Volumes 是一回事么？</h2>

<p>No, they are actually quite different.</p>

<p>A storage driver is how docker implements a particular union file system. Keeping with are “batteries included, but replaceable” philosophy, Docker supports a number of different union file systems. For instance, Ubuntu’s default storage driver is AUFS, where for Red Hat and Centos it’s Device Mapper.</p>

<p>A volume is subdirectory in a container’s file system that exists outside of the union file system.  Unless you explicitly commit changes made to a Docker container during run time to a new image, they are lost when the container is destroyed. Volumes, by contrast, will not be automatically deleted when a container is removed (you can, of course, tell Docker to remove any volumes when removing a container).</p>

<h2 id="nfs">用NFS共享卷作为容器的卷有什么问题么？</h2>

<p>Not really. This is a pretty common scenario.</p>

<h2 id="dockerimage">如何将更新后的Docker容器导出为可以重用的新的Image？</h2>

<p>You can do this by using docker commit. In an example where you have a container named “mywebsite” the following command would create a new image named “mikegcoleman\mynginx” from that container</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker commit mywebsite mikegcoleman<span class="se">\m</span>ynginx
</code></pre>
</div>

<h2 id="section">如何对容器做安全加固？</h2>

<p>Visit the Docker Security resource center to get access to tools and best practices in securing your Docker implementation.</p>

<h2 id="ram--cpu">如何配置容器对(RAM 和 CPU)资源的用量？</h2>

<p>CPU and RAM can be configured via the docker run command. You can read about memory here, and CPU here.</p>

<h2 id="rhel-based-image-">我想用 RHEL based image 怎么办？</h2>

<p>Red Hat hosts a variety of docker images, but you must be a Red Hat subscriber to access them.</p>

<h2 id="rhel-containers-vs-docker-containers-">RHEL containers vs. Docker containers 他们的区别？</h2>

<p>The Docker engine that runs on Red Hat Enterprise Linux (RHEL), offers the same functionality as the Docker engine running on any other Linux distribution. Additionally, If you are a Red Hat subscriber, you can run RHEL inside of a container on any host running Docker engine.</p>

<h2 id="solaris-os--docker--centos">如果，我用 Solaris OS 运行 Docker 是支持的, 这意味这我能用来跑CentOS的容器么？</h2>

<p>We are working with Oracle to implement Docker with <a href="https://blog.docker.com/2015/08/docker-oracle-solaris-zones/">Solaris Zones</a>, but this funcitonaity is not yet generally available. When it does ship, however, it will allow Docker to run Solaris workloads on Solaris, but it won’t allow to run Linux workloads on Solaris. Similarly, the Docker Engine that will run on Windows when Microsoft ships its container support with Windows Server 2016 will run Windows workloads, not Linux workloads.</p>

<p>That being said, the Illumos kernel has support for a feature called “BrandZ,” which allows running Linux binaries on the Illumos kernel. Joyent’s Triton product leverages on this feature to run Linux containers on their SmartDataCenter platform, which uses the Illumos kernel.</p>

<h2 id="oracle-12g-rac---fencing-docker">少数象 Oracle 12g RAC 这样的应用需要动态的调整 内核参数，而且有 fencing 的概念，Docker将会支持么？</h2>

<p>It might work, but it’s not something we advocate as  a good use case. Docker is designed for microservices or distributed applications. Each container should, ideally, perform a single function. You tie those containers together to create complex applications. Large monolithic applications like Oracle, are not a particularly good use case for containers.</p>

<h2 id="web--glusterfs-">当运行10个Web容器，如何为他们设置共享文件系统数据，例如上传的文件？ 能用类似 GlusterFS 的文件系统么？</h2>

<p>Without knowing more specifics on the use case, it’s hard to say exactly what the best approach would be. However, using a shared data-only container with volumes mounted to house the shared data would be a good place to start.</p>

<p>As for Gluster, I’m not sure it’ll solve the problem you’re trying to solve by itself. That being said, customers have deployed Docker volumes to GlusterFS with success. Just make sure you understand the characteristics of the file system – in particular how to tune it appropriately.</p>

<h2 id="section-1">如果你去配置和映射一个本地目录作为容器的一个卷，当你需要让这个应用上生产环境，最佳实践是什么？</h2>

<p>The app code should be copied into the Docker image. The idea is that your Docker image includes everything the app needs to execute including the code and any libraries or dependencies.</p>

<h2 id="data-only-containers--host-mounting-">由于 data-only containers 依然存储数据在运行的主机上，为什么这还是会比 host-mounting 方式要好？</h2>

<p>Host mounting  ties the volume mount point to one specific Docker host. With data-only containers, the volume is mounted to a container, and that abstraction works across different Docker hosts.</p>

<p>Wouldn’t a data container suffer from the same problem as writing data to a container over time? I.e. the build up of diffs may cause longer look up times due to folder traversal.</p>

<p>When we talk about data-only containers, we talk about them in the context of hosting a volume in that container. Since we’re using a volume, it bypasses the union file system, and isn’t affected by some of the performance issues.</p>

<h2 id="section-2">备份和版本控制的最佳实践是什么？</h2>

<p>These are pretty broad topics, but I’ll give a couple quick answers with the fact that we’re doing a session on October 27th that will talk about backups in pretty good detail.</p>

<p>Part of the reason for storing your data in volumes is it makes it fairly trivial to backup. Information on the hows and whats can be found in the Docker documentation.</p>

<p>As for version control, I’m not exactly sure what you mean, but I’ll take a crack at it anyway. As a best practice we recommend using Dockerfiles to control the creation of new Docker images. Those Dockerfiles should be stored in GitHub, and treated like any other source code. Additionally, when images are pushed to a registry, they can be tagged with a version number so you can keep older versions around or be explicit about which version you wish to use in the future.</p>

<p>来源：<a href="http://blog.docker.com/2015/10/docker-basics-webinar-qa/">http://blog.docker.com/2015/10/docker-basics-webinar-qa/</a></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-09-30T16:00:00+00:00"><a href="http://yzd.io/container/containers-101-bob-reselman/">September 30, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://yzd.io/about/" title="About Martin Liu">Martin Liu</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
预计阅读时间 ~1 分钟

      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://yzd.io/container/containers-101-bob-reselman/" rel="bookmark" title="Container 101 - Bob Reselman" itemprop="url">Container 101 - Bob Reselman</a></h1>
    
  </header>
  <div class="entry-content">
    <p>阅读提示：在看一些翻译文章的时候，需要看看是什么人？什么时候？在那里发布的文章？为什么发布这个文章？特别是对不熟悉的作者还是有必要去linkedin查一下这个人的工作记录，曾经的就职情况，曾经的出版物主要有那些？以上都是看看此人的江湖地位和背景，主要是看它写文章是否带有某种立场和角度；这年头毕竟枪文太多，还是需要有防胡悠的意识。</p>

<p>作者简介：Bob Reselman 目前是Edmunds公司的技术流程架构师。Edmunds公司是一家知名发布商，专门发布高容量、高可用性、最先进的、基于Java的网站，这些网站专门面向汽车消费者。</p>

<p><img src="/images/2015/10/Bob-Reselman.jpg" alt="Bob Reselman" /></p>

<ul>
  <li><a href="https://www.linkedin.com/in/bobreselman">Linkedin profile</a></li>
</ul>

<p>本文正文的出处：<a href="http://www.developer.com/design/containers-101.html">http://www.developer.com/design/containers-101.html</a> 下面是云头条的中文翻译。</p>

<p>大概六个月前，我就开始注意到业界在容器方面的动静很大，容器被誉为是一种处理虚拟计算的新方法。我生性喜欢探究新技术，于是这几个开始研究容器技术的细枝末节。我可以告诉各位的是，容器是不会很快销声匿迹的一项重要技术。这个领域有许多玩家，新厂商一直在涌进来。如果你是与时俱进的开发人员，学会使用容器是职业生涯中必不可少的技能。</p>

<p>所以，本着倡导一种优秀技术概念的宗旨，我想回答下列问题，为各位介绍容器技术的基本知识：</p>

<ol>
  <li>何谓容器？</li>
  <li>容器有何特别之处？</li>
  <li>该如何使用容器？</li>
</ol>

<p>我希望，回答这些问题后，你对容器有一个基本的了解和认识，以便开发和部署代码时可以开始使用容器。</p>

<p>还是言归正传吧。</p>

<h2 id="section">何谓容器？</h2>

<p>容器技术是通过使用主机上的隔离进程，建立虚拟环境的一种方法。这种隔离进程就叫容器，它有自己的一套文件系统资源和从属进程。容器不会侵扰主机系统，主机系统也不会侵扰容器。</p>

<p>容器在主机内核上运行（见图1）。一个名为容器管理器的组件确保容器可以在主机上运行（文章后面对容器管理器会有详细介绍）。</p>

<p><img src="/images/2015/10/Contain1.jpg" alt="图1：" /></p>

<ul>
  <li>图1：容器提供了运行孤立进程的功能，孤立进程在共享环境下有自己的资源。</li>
</ul>

<h2 id="section-1">容器有何特别之处？</h2>

<p>想了解什么让容器如此特别，我们就需要审视虚拟机这个概念。虚拟机是一个模拟计算机的软件。虚拟机的优点在于，可以大大提高使用硬件的效率。你可以让好多虚拟机在单单一个硬件上运行（见图2）。</p>

<p><img src="/images/2015/10/Contain2.gif" alt="图2" /></p>

<ul>
  <li>图2：如果你使用虚拟机，针对每个虚拟机的资源分配是固定的。</li>
</ul>

<p>然而，虚拟机技术有其缺点。不妨看一下图2。你会注意到，在图中，三个虚拟机在一台计算机上运行，该计算机配备48 GB内存、12核处理器和3TB磁盘存储空间。每个虚拟机被分配了16 GB内存、4核和1TB存储空间。到目前为此很好。但是这里有个缺点。无论任何一个虚拟机使用它的全部资源，还是只是一小部分资源，硬件分配是静态的。换句话说，如果其中一个虚拟机使用的内存从不超过1GB，只存储100MB的文件系统，该虚拟机仍占用4 GB内存和整整1TB的存储空间，尽管该虚拟机只使用25%的内存和1%的存储空间。这就不太好。</p>

<p>另一方面，容器并不死死占用资源。你构建一个容器时，不用为它分配内存、处理器或存储空间。事实上，容器以共享方式使用主机上的内存、处理器和存储空间。只要物理机处理得了，可以将好多个容器装入到该物理机上。容器只有在需要资源时才占用所需的那部分资源。不存在资源分配是固定的说法。</p>

<p>好处不止这些。运行容器的硬件通常使用轻量版Linux作为操作系统。这个轻量级主机操作系统提供了内核级服务。CoreOS是流行的主机操作系统之一。还有其他主机操作系统，比如Ubuntu Snappy和Red Hat Atomic。</p>

<p>你在构建容器时，可以添加所选择的操作系统；比如说，你想使用Ubuntu。容器里面的Ubuntu操作系统会充分利用主机内核，不过会有属于Ubuntu一部分的程序包。比如说，虽然内核对软件包管理一无所知，但Ubuntu会提供软件包管理工具apt-get。此外，你可以配置容器，以便使用特殊的Web服务器和脚本解释器等等。结果就是，你获得了虚拟机提供的环境配置，又不因静态分配而死死占用主机系统上的资源。另外，容器会有一个主机里面可见的IP地址。因而，主机可以通过容器的IP地址，直接访问容器（见图3）。</p>

<p><img src="/images/2015/10/Contain3.jpg" alt="图3" /></p>

<ul>
  <li>图3：容器共享主机资源，并充分利用主机操作系统提供的内核级服务。</li>
</ul>

<h2 id="windows">附文：使用Windows怎么样？</h2>

<p>容器面临的一个约束是，无法混合搭配多个操作系统。在虚拟机领域，让Windows主机支持运行Linux的虚拟机或者让OS X系统运行Windows虚拟机相当常见。而容器就不是这样了；原因是，就本身而言，容器使用主机内核。因而，你要做到操作系统相互匹配。也就是说，Linux容器在Linux主机上运行。你可以在Windows Server（直至Windows Server 2016）上运行Windows容器。另外，还有Windows版的容器管理器：Docker。</p>

<p>要是你发现自己需要在Windows上运行Linux容器，总是可以在Windows下启动Linux虚拟机，使用Linux虚拟机作为主机系统。</p>

<h2 id="section-2">该如何使用容器？</h2>

<p>为了使用容器，你就要明白三个概念。第一个概念是容器管理器。第二个是了解容器层架构。第三个是容器注册中心。</p>

<h3 id="section-3">容器管理器</h3>

<p>容器管理器是一种工具，可用来构建容器、部署容器，让容器在主机上运行。截至本文截稿时，市面上最流行的容器管理器是Docker和Rocket。</p>

<p>容器管理器的工作方式如下：假设你用PHP编写了一个短小的Hello World Web应用程序。你要创建一个容器配置文件，你会在其中描述应用程序所需的PHP文件。同样在该配置文件中，你要定义应用程序所需的各层。在这里，假设你的应用程序需要PHP 5.6解释器，你想要在Apache网站服务器下运行。到时就可以通过容器管理器，发出命令来运行你的应用程序。容器管理器在后台会执行这些操作：</p>

<ol>
  <li>读取配置文件，确定需要从注册中心获得的各层；</li>
  <li>创建容器映像；</li>
  <li>添加应用程序源文件；以及</li>
  <li>在主机上启动容器（见图4）。</li>
</ol>

<p><img src="/images/2015/10/Contain4.jpg" alt="图4" /></p>

<ul>
  <li>图4：配置文件、映像和注册中心都是容器生态系统的一部分。</li>
</ul>

<p>听起来觉得很简单？你可能会问：“层是什么？映像是什么？注册中心是什么？怎么回事？”这些问题提得好，有必要回答。下面我就逐一回答。</p>

<h3 id="section-4">了解层和映像</h3>

<p>容器由一个个层组成。层就是容器映像（没错，容器由其他容器组成这个概念一开始可能让人困惑）。可能先是操作系统底层。然后，你声明其他层，比如说Web服务器和脚本运行时环境。一旦定义好了容器，就可以在已定义容器的基础上构建映像。映像是容器的模板，你可以在一个或多个主机上重复使用它。</p>

<p>图5表明了主机运行CoreOS、使用Docker作为容器管理器的一种场景。有三个容器在主机上运行。一个容器使用Debian作为基本的操作系统层，Apache用作网站服务器，PHP 5.5用作脚本运行时环境，还使用自定义PHP应用程序（已为它构建了容器）。另一个容器用于额外的自定义PHP应用程序，使用nginx作为网站服务器，PHP 5.6作为脚本解释器，它们都在RHEL基本映像上运行。最后，第三个容器有一个JSP应用程序在Tomcat和Apache上运行，位于Ubuntu基本映像上。</p>

<p><img src="/images/2015/10/Contain5.jpg" alt="图5" /></p>

<ul>
  <li>图5：容器映像可以定义某个特殊主机为基本映像，然后分别为网站服务器、脚本运行时环境和脚本文件添加层。</li>
</ul>

<p>正如你所见，每个容器都不一样。不过，它们都作为孤立进程而并行驻留在主机上，可以利用CoreOS内核。没有实施硬件分配机制。所有环境资源都可以共享。</p>

<h3 id="section-5">了解注册中心</h3>

<p>容器映像存储在注册中心里面。对熟悉Java框架的人而言，注册中心概念好比是Maven注册中心概念。而.NET环境中的类似技术就是NuGet服务器。</p>

<p>有许多公开的注册中心，你可以将容器映像存储在里面。Docker有Docker Hub，还有其他公开的注册中心。另外，如今出现了越来越多的私有注册中心提供商。</p>

<p>使用注册中心几乎自动会收到神奇效果。你告诉容器管理器运行容器后，它会检查配置文件，确定容器需要哪几个层，然后检查注册中心上面的所需层映像，或者是默认注册中心，或者是你定义的注册中心。容器管理器会组装你的容器从注册中心需要获取的几个层，然后将容器装入到主机上。</p>

<p>使用注册中心让你在容器映像方面拥有高度可重用性。另外，使用容器映像意味着，你可以扩展应用程序，如下文所示。</p>

<h3 id="section-6">扩展容器</h3>

<p>容器在需要根据需求扩增或缩减资源的动态环境下表现很出色。不像虚拟机要花很长时间才能装入到主机环境，容器可以迅速装入。装入迅速，加上无所不在的容器注册中心，这意味着你可以迅速构建起高可用性、负载均衡的环境。</p>

<p>请看一下图6。该图显示了基于容器的应用程序集群环境。如今，让负载均衡系统协调从同一映像生成的许多容器之间的负载相当常见。实际上，负载均衡系统本身可以是个容器。换句话说，你可以使用nxginx容器作为负载均衡系统，负责协调相同应用程序节点组成的集群之间的流量。</p>

<p><img src="/images/2015/10/Contain6.jpg" alt="图6" /></p>

<ul>
  <li>图6：你可以使用充当负载均衡系统的容器来管理应用程序容器集群。</li>
</ul>

<h2 id="section-7">现在怎么办？</h2>

<p>容器生态系统在迅速发展壮大。比如说，有谷歌的开源项目Kubernetes，该项目提供了一个平台，可用于在企业层面，跨主机集群部署和扩展应用程序容器。另一个开源项目etcd让你可以共享容器之间的键值信息。如果你需要让容器使用统一的数据存储区或缓存，共享键值信息就很重要。还有fleet，它确保了这一点：如果你在诸多机器上运行许多同样的容器，其中一个机器出现故障，容器可以转移到另一个机器上。这在大规模计算环境下是一种非常有效的技术；在这种环境下，你的容器始终运行至关重要。这方面的项目和产品在迅速涌现。</p>

<p>正如我在文章开头所说，容器不会很快销声匿迹。实际上，微软、谷歌、IBM、红帽、亚马逊及其他许多知名科技公司已联合起来，组建了开放容器项目（Open Container Initiative），这是在Linux基金会下面成立的。设想一下：微软与Linux领导厂商合作。所以，如果雷德蒙德的人全力搭上容器这趟快车，容器进入到你我的世界只是个时间问题。所以，如果你还没有开始接触容器，现在正是时候。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-09-30T00:00:00+00:00"><a href="http://yzd.io/container/container-tech-stack/">September 30, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="http://yzd.io/about/" title="About Martin Liu">Martin Liu</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
预计阅读时间 ~1 分钟

      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://yzd.io/container/container-tech-stack/" rel="bookmark" title="Container技术栈概述" itemprop="url">Container技术栈概述</a></h1>
    
  </header>
  <div class="entry-content">
    <p>应用架构驱动着基础设施架构的发展。下一代应用架构聚焦于社交、移动、大数据、智能硬件，驱动应用向着更好的用户体验发展，也对传统的技术架构产生了冲击。</p>

<p>本文我们将看下新一代技术架构的元素，以及公司在下一代应用和基础设施中，应当如何进行架构选型。</p>

<p>在过去的6-12个月里，Container技术引起了企业的CIO、架构师和开发人员的极大兴趣。</p>

<ul>
  <li>Container技术引起CIO兴趣的原因在于，他们找到了向现代应用框架快速转型的方法，从而驱动业务的发展。</li>
  <li>对于架构师来说，Container技术增强了应用的可移植性，适用于混合云架构。</li>
  <li>而开发人员通过Container技术，可以快速地应用微服务架构，增强应用的可扩展性。</li>
</ul>

<p>DockerCon 和 Red Hat Summit 中，都曾讨论过这一趋势。但是每种新技术，都会带来新的挑战和利弊权衡。本文将对container技术架构中的元素逐一进行分析。</p>

<p>下图为Docker技术人员 Patrick Chanezon 总结的Container技术栈：</p>

<p><img src="/images/2015/09/docker-stack.png" alt="docker tech stack" /></p>

<p>在深入了解Container技术架构之前，有必要先理解以下几个基本问题：
   * Container技术非常适用于分布式应用框架中，这意味着底层的Container基础架构必须是模块化和非常灵活的；
   * 以下所探讨的核心概念，很多来源于如今的虚拟化架构，比如服务发现（Service Discovery），集群管理（Cluster Management）和资源调度（Resource Scheduling）；
   * 围绕整个container技术架构的公司生态也在快速发展，多数情况下，他们都从单一的工具开始，慢慢发展为一个全栈服务。</p>

<h2 id="container">深入Container技术架构</h2>

<p>从单一的Container到服务于产品的架构，需要一系列的工具和配置。从这些工具和配置上，我们可以看出下一代基于Container的应用需要哪些组件：</p>

<p>首先，要进行以下声明：
  * 所有这些组件都不是硬件的，也不依赖于云服务；
  * 在实现时，可能会结合一些组件到一个软件中；
  * 并非所有组件都是必须的。</p>

<p>下面是对整个技术栈自下而上的分析。</p>

<h3 id="devops">DevOps工具</h3>

<p>叫“开发工具”和“运维工具”更加直观，他们运行在本地机器上，用来启动Container，虚拟机或初始化应用包。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Hashicorp Vagrant，Docker Machine，VMware AppCatalyst, Shippable, Wercker
</code></pre>
</div>

<h3 id="vm">物理宿主机（或VM）</h3>

<p>Container实际运行的机器，可能是一个本地的笔记本电脑，一个数据服务器或一个公有云实例。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>VMware ESX，Microsoft Hyper-V，KVM，LXD
</code></pre>
</div>

<h3 id="container-os">Container OS</h3>

<p>负责和底层物理宿主机交互的操作系统（Linux或Windows），还负责提供所有container共享的OS级别的服务。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CoreOS，RedHat Atomic Host，Rancher OS，Canonical Snappy，VMware Photo
</code></pre>
</div>

<h3 id="container-runtime">Container Runtime</h3>

<p>创建、启动、停止、销毁Container的软件层。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker，Rkt，Lattice
</code></pre>
</div>

<h3 id="container-1">Container</h3>

<p>管理着应用和Container OS之间的交互。也有人将其类比为虚拟机，但是container并不包含一个完整的操作系统。</p>

<h3 id="marketplace">Marketplace/镜像管理</h3>

<p>储存和管理container镜像的服务器（自己搭建或采用云端的SaaS应用）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker Registry，CoreOS Registry
</code></pre>
</div>

<h3 id="configuration-management">配置管理（Configuration Management）</h3>

<p>管理和自动化配置文件和部署的工具。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>比如Ansible，Chef，Puppet，Docker Compose，Terraform
</code></pre>
</div>

<h3 id="container-networking">Container Networking</h3>

<p>SDN，管理container之间包路由的网络框架。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker Networking，WeaveWorks，Flannel (CoreOS), Calico
</code></pre>
</div>

<h3 id="container-2">Container集群管理</h3>

<p>帮助建立Container集群，形成服务，管理集群资源，保障可用性。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker Swarm, Hashicorp Serf
</code></pre>
</div>

<h3 id="section">服务发现</h3>

<p>随着更多的元素/微服务 被加入到应用中，找到这些服务并确认其是否可用变得很困难。服务发现可以在其加入网络中时，管理广播和服务许可。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker Swarm, Hashicorp Serf
</code></pre>
</div>

<h3 id="container-">Container 调度</h3>

<p>这项服务保障了container在宿主机中处于最高效的位置，容量规划，失败时重启container，需求变化时扩展应用等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Kubernetes，Mesos
</code></pre>
</div>

<h3 id="section-1">应用调度</h3>

<p>和container调度的功能类似，是一系列面向应用的服务，描述应用被部署时所需的资源，时间，依赖等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Marathon，Chronos，Hadoop，Spark
</code></pre>
</div>

<h3 id="section-2">安全</h3>

<p>在container架构中，同样需要所有的安全组件，从OS到认证服务，到数据管理。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CoreOS Linux，Intel Clear Containers，Docker Notary，Hashicorp Vault, OpenSCAP, Twistlock, Scalock, Conjur, Lynis
</code></pre>
</div>

<h3 id="section-3">日志管理</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker logs, logspout
</code></pre>
</div>

<h3 id="section-4">监控/可视化</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>Docker ps/top/stats, Docker stats API, sysdig, cAdvisor, Weave Scope
</code></pre>
</div>

<h3 id="container-3">Container实现——灵活性，交互性以及挑战</h3>

<p>对于企业来说，Container技术的挑战之一在于，选择Container技术栈意味着舍弃传统的，由ISV提供的一站式“单块架构”，通常会令企业望而生畏。</p>

<p>第二个挑战在于，初创公司常常将个人项目作为工具，许多情况下，要么是某公司在主导这个项目，要么由一个开源社区主导。</p>

<p>第三个挑战在于许多工具是彼此协作和可替代的。许多早期用户会试用不同项目的组件，而不是由一个供应商或开源项目提供的技术栈。短期来讲，有助于早期采用者实现灵活性和技术的多样性。长期来看，不利于企业对稳定环境的需求，同时也会增加对新技术的学习成本。相关的公有云服务，比如Amazon Elastic Cloud Services和 Google Container Engine，可以帮助用户屏蔽技术上的复杂性。</p>

<h2 id="section-5">总结</h2>

<p>Container技术和架构产生和发展都很迅速。许多初创企业都在驱动新工具和框架的产生，能够将合适的架构组件组合起来的技术，将为企业带来很多优势。不管基于已有的基础架构还是公有云，随着更多的解决方案级别的产品被推向市场，Container技术的发展脉络也将逐步清晰。</p>

<p>本文译自wikibon文章《Evolving Container Architectures》，原文请点击 <a href="http://wikibon.com/evolving-container-architectures/">阅读原文</a></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://yzd.io" class="btn">前一页</a></li>
      
    

    
    
      <li><a href="http://yzd.io">1</a></li>
    

    
    

    
    
    

    
      
        <li><strong class="current-page">2</strong></li>
      
    

    
    

    
      <li><a href="http://yzd.io/page3/">3</a></li>
    

    
    
      <li><a href="http://yzd.io/page3/" class="btn">下一页</a></li>
    
  </ul>
</div>


</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2016 Martin Liu. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>

  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://yzd.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://yzd.io/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77731594-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>